%{
// Declaraciones de código C si es necesario
#include "SyntacticActions.h"
#include "gramatica.tab.hpp"
#include "../IntermediateCodeGenerator/IntermediateCodeGenerator.h"
%}

%token SHORT UINT DOUBLE VOID CLASS INTERFACE IMPLEMENT IMPL
%token IF ELSE END_IF PRINT FOR IN RANGE RETURN





%union {
        int number = 0;
        char *string;
}

%token <string> LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL PLUS_EQUAL // Operadores de comparación
%token <string> ID STRING CTE_SHORT CTE_UINT CTE_DOUBLE
%type <string> factor constante expresion asignador termino expresion_parentesis comparador condicion bloque_sentencias asignacion seleccion bloque_else bloque_if argumento_bucle_for

%left '=' PLUS_EQUAL  // Asociatividad izquierda para asignación y asignación con adición
%left '.'  // Asociatividad izquierda para acceso a atributos y métodos

%start programa

%%

programa        : '{' sentencias '}'
                | '{' sentencias        { Logger::logError("Se esperaba llave como fin del programa") }
                | sentencias '}'        { Logger::logError("Se esperaba llave como inicion del programa") }
                ;

sentencias      : sentencia
                | sentencias sentencia
                ;

sentencia       : declarativa ','
                | ejecutable ','
                ;

declarativa     : declaracion_variables { Logger::infoMsg("Declaracion de variables") }
                | clase_declaration
                | objeto_declaration
                | interface_declaration
                | implement_declaration
                | distributed_method_implementation
                | funcion_declaration
                ;

ejecutable      : asignacion
                | invocacion
                | seleccion
                | print
                | bucle_for
                | acceso_atributo
                | retorno       { SyntacticActions::checkReturnScope() }
                ;

declaracion_variables   : tipo lista_variables
                        | error lista_variables       { Logger::logError("Falta especificar el tipo de las variables") }
                        ;

lista_variables : lista_variables ';' ID        { IntermediateCodeGenerator::setVarScope($3) }
                | ID                            { IntermediateCodeGenerator::setVarScope($1) }
                | ID error ','    { Logger::logError("declaracion de variables invalida") }
                ;

clase_declaration       : CLASS ID '{' atributos metodos_clase herencia_composicion '}' { Logger::infoMsg("Declaracion de clase") }
                        ;

interface_declaration   : INTERFACE ID '{' interface_metodos '}' { Logger::infoMsg("Declaracion de interfaz") }
                        ;

interface_metodos       : interface_metodos interface_metodo_declaration
                        |
                        ;

encabezado_funcion      : VOID ID       { IntermediateCodeGenerator::addScope($2); }
                        ;

interface_metodo_declaration    : encabezado_funcion '(' parametro ')' ',' { Logger::infoMsg("Declaracion de metodo de interfaz");
                                                                                IntermediateCodeGenerator::onScopeFinished() }
                                ;

implement_declaration   : CLASS ID IMPLEMENT ID '{' metodos_clase herencia_composicion '}' { Logger::infoMsg("Implementacion de interfaz") }
                        ;

atributos               : atributos atributo_declaration
                        |
                        ;

atributo_declaration    : declaracion_variables ',' { Logger::infoMsg("Declaracion de atributos de clase") }
                        ;

metodos_clase   : metodos_clase metodo_declaration
                |
                ;

metodo_declaration      : funcion_declaration ',' { Logger::infoMsg("Declaracion de metodo") }
                        ;

funcion_declaration     : encabezado_funcion '(' parametro ')' '{' sentencias_metodo '}' { Logger::infoMsg("Declaracion de funcion");
                                                                                                IntermediateCodeGenerator::onScopeFinished() }
                        |
                        ;

herencia_composicion    : herencia_composicion ID ','   { Logger::infoMsg("Herencia por composicion") }
                        |
                        ;

sentencias_metodo       : sentencias_metodo declaracion_variables ','
                        | sentencias_metodo ejecutable ','
                        | sentencias_metodo local_function_declaration ','
                        |
                        ;

local_function_declaration      :  encabezado_funcion '(' parametro ')' '{' sentencias_funcion_local '}' { Logger::infoMsg("Declaracion de funcion local");
                                                                                                                IntermediateCodeGenerator::onScopeFinished() }
                                ;

sentencias_funcion_local        : sentencias_funcion_local declaracion_variables ','
                                | sentencias_funcion_local ejecutable ','
                                | sentencias_funcion_local local_function_declaration ',' { Logger::logError("No se permite anidamiento multiple de funciones locales") }
                                |
                                ;

parametro       : tipo ID
                | ID                    { Logger::logError("Falta el tipo del argumento") }
                | parametro ';' tipo ID { Logger::logError("Solo se permite un parametro en declaracion de funcion") }
                |
                ;

distributed_method_implementation       : IMPL FOR ID ':' '{' metodos_clase '}'    { Logger::infoMsg("Declaracion distribuida de metodos") }
                                        ;
                        
retorno                 : RETURN
                        ;

objeto_declaration      : ID lista_objetos
                        ;

lista_objetos           : lista_objetos ';' objeto
                        | objeto
                        ;

objeto          : ID
                ;

asignacion      : ID asignador expresion        { Logger::infoMsg("Asignacion simple"); IntermediateCodeGenerator::addTerceto($2, $1, $3) }
                | ID '.' ID asignador expresion  { Logger::infoMsg("Asignacion de atributo");
                char *aux = (char*) malloc(sizeof($1) + sizeof($3) + 2);
                sprintf(aux, "%s.%s", $1, $3);
                IntermediateCodeGenerator::addTerceto($4, aux, $5);
                }
                | ID asignador  { Logger::logError("Asignacion vacia") }
                | ID '.' ID asignador    { Logger::logError("Asignacion vacia") }
                | ID asignador '-'       { Logger::logError("Asignacion vacia") }
                ;

asignador       : '=' { 
                        char *aux = (char*) malloc(sizeof(char) * 2);
                        aux[0] = '=';
                        aux[1] = '\0';
                        $$ = aux;
                }
                | PLUS_EQUAL { 
                        char *aux = (char*) malloc(sizeof(char) * 3);
                        aux[0] = '+';
                        aux[1] = '=';
                        aux[2] = '\0';
                        $$ = aux;
                 }
                ;

invocacion      : ID '(' argumentos ')' { Logger::infoMsg("Invocacion de funcion") }
                | ID '.' ID '(' argumentos ')'  { Logger::infoMsg("Invocacion de metodo") }
                ;

argumentos      : expresion
                | argumentos ';' expresion      { Logger::logError("Solo se permite un argumento en invocacion de funcion") }
                |
                ;

seleccion       : IF '(' condicion ')' bloque_if ELSE bloque_else END_IF  { Logger::infoMsg("Sentencia IF completa"); IntermediateCodeGenerator::ifElseExpression($3, $5, $7); }
                | IF '(' condicion ')' bloque_if END_IF { Logger::infoMsg("Sentencia IF sin ELSE"); IntermediateCodeGenerator::ifExpression($3, $5); }
                | IF '(' condicion ')' bloque_if { Logger::logError("Falta sentencia END_IF") }
                | IF '(' condicion ')' bloque_if ELSE bloque_else { Logger::logError("Falta sentencia END_IF") }
                ;

bloque_if       : bloque_sentencias { IntermediateCodeGenerator::addTerceto("BI", "", ""); IntermediateCodeGenerator::addStack(IntermediateCodeGenerator::lastTerceto); $$ = IntermediateCodeGenerator::getLastTerceto() }

bloque_else     : bloque_sentencias

condicion       : expresion comparador expresion        { Logger::infoMsg("Condicion de control");  IntermediateCodeGenerator::addTerceto($2, $1, $3); IntermediateCodeGenerator::endCondition(); $$ = IntermediateCodeGenerator::getLastTerceto();}
                | expresion comparador          { Logger::logError("Se esperaba expresion en lado derecho de comparacion") }
                | comparador expresion          { Logger::logError("Se esperaba expresion en lado izquierdo de comparacion") }
                | expresion                     { Logger::logError("Se esperaba un operador de comparacion") }
                ;

comparador      : '<' { 
                        char *aux = (char*) malloc(sizeof(char) * 2);
                        aux[0] = '<';
                        aux[1] = '\0';
                        $$ = aux;
                }
                | '>' {
                        char *aux = (char*) malloc(sizeof(char) * 2);
                        aux[0] = '>';
                        aux[1] = '\0';
                        $$ = aux;
                }
                | LESS_EQUAL {
                        char *aux = (char*) malloc(sizeof(char) * 3);
                        aux[0] = '<';
                        aux[1] = '=';
                        aux[2] = '\0';
                        $$ = aux;
                }
                | GREATER_EQUAL {
                        char *aux = (char*) malloc(sizeof(char) * 3);
                        aux[0] = '>';
                        aux[1] = '=';
                        aux[2] = '\0';
                        $$ = aux;
                }
                | EQUAL {
                        char *aux = (char*) malloc(sizeof(char) * 3);
                        aux[0] = '=';
                        aux[1] = '=';
                        aux[2] = '\0';
                        $$ = aux;
                }
                | NOT_EQUAL {
                        char *aux = (char*) malloc(sizeof(char) * 3);
                        aux[0] = '!';
                        aux[1] = '=';
                        aux[2] = '\0';
                        $$ = aux;
                }
                ;
        
bloque_sentencias       : sentencia { $$ = IntermediateCodeGenerator::getLastTerceto(); }
                        | '{' sentencias '}' { $$ = IntermediateCodeGenerator::getLastTerceto(); }
                        ;

print   : PRINT STRING  { Logger::infoMsg("Sentencia PRINT"); IntermediateCodeGenerator::addTerceto("PRINT", $2, ""); }
        | PRINT         { Logger::logError("Se esperaba cadena para imprimir") }
        | STRING        { Logger::logError("Falta sentencia PRINT") }
        ;

bucle_for       : FOR ID IN RANGE '(' argumento_bucle_for ')' bloque_sentencias { Logger::infoMsg("Sentencia FOR"); IntermediateCodeGenerator::forBlock($2, $8) }
                | ID IN RANGE '(' argumento_bucle_for ')' bloque_sentencias    { Logger::logError("Falta sentencia FOR") }
                | FOR IN RANGE '(' argumento_bucle_for ')' bloque_sentencias    { Logger::logError("Se esperaba una variable") }
                | FOR ID IN '(' argumento_bucle_for ')' bloque_sentencias    { Logger::logError("Falta sentencia RANGE") }
                | FOR ID RANGE '(' argumento_bucle_for ')' bloque_sentencias    { Logger::logError("Falta sentencia IN") }
                ;

argumento_bucle_for     : constante ';' constante ';' constante { IntermediateCodeGenerator::forArguments($1, $3, $5) }
                        | constante ';' constante { Logger::logError("Sentencia FOR recibe 3 parametros, 2 encontrados") }
                        | constante { Logger::logError("Sentencia FOR recibe 3 parametros, 1 encontrados") }
                        |       { Logger::logError("Sentencia FOR recibe 3 parametros, ninguno encontrado") }
                        ;

acceso_atributo : ID '.' ID     { Logger::infoMsg("Acceso a atributo") }
                ;

expresion       : expresion '+' termino { IntermediateCodeGenerator::addTerceto("+", $1, $3); $$ = IntermediateCodeGenerator::getLastTerceto(); }
                | expresion '-' termino { IntermediateCodeGenerator::addTerceto("-", $1, $3); $$ = IntermediateCodeGenerator::getLastTerceto(); }
                | tipo '(' expresion ')' { Logger::logError("Conversion explicita no permitida") }
                | expresion '+' '(' expresion_parentesis ')' { IntermediateCodeGenerator::addTerceto("+", $1, $4); $$ = IntermediateCodeGenerator::getLastTerceto();}
                | expresion '-' '(' expresion_parentesis ')' { IntermediateCodeGenerator::addTerceto("-", $1, $4); $$ = IntermediateCodeGenerator::getLastTerceto();}
                | '(' expresion_parentesis ')' { $$ = $2; }
                | termino { $$ = $1; }
                ;



expresion_parentesis    : '(' expresion_parentesis ')' { Logger::logError("Anidamiento de expresiones con parentesis no permitida") }
                        | termino '+' termino
                        | termino '-' termino
                        | termino
                        ;

termino         : factor { $$ = $1; }
                | termino '*' factor { IntermediateCodeGenerator::addTerceto("*", $1, $3); $$ = IntermediateCodeGenerator::getLastTerceto(); }
                | termino '/' factor { SyntacticActions::check_division_by_zero($3); IntermediateCodeGenerator::addTerceto("/", $1, $3); $$ = IntermediateCodeGenerator::getLastTerceto(); }
                ;

factor          : ID { $$ = $1; }
                | '-' constante { SyntacticActions::addNegativeConstant($2) }
                | constante     { SyntacticActions::checkLimits($1); $$ = $1; }
                ;

constante       : CTE_SHORT     { $$ = $1; SyntacticActions::lastType = CTE_SHORT; }
                | CTE_DOUBLE    { $$ = $1; SyntacticActions::lastType = CTE_DOUBLE; }
                | CTE_UINT      { $$ = $1; SyntacticActions::lastType = CTE_UINT; }
                ;

tipo    : SHORT
        | UINT
        | DOUBLE
        ;
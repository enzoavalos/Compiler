%{
// Declaraciones de código C si es necesario
#include "SyntacticActions.h"
%}

%token SHORT UINT DOUBLE VOID CLASS INTERFACE IMPLEMENT IMPL
%token IF ELSE END_IF PRINT FOR IN RANGE RETURN

%token LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL PLUS_EQUAL // Operadores de comparación

// Pregunta, que = sea asociativo a izquierda es parte de las consignas? Crei que era a derecha (en general)
%left '=' PLUS_EQUAL  // Asociatividad izquierda para asignación y asignación con adición
%left '.'  // Asociatividad izquierda para acceso a atributos y métodos

%nonassoc UMINUS  // Operador de negación unaria (para expresiones negativas) Esto lo recomendo chatgpt, veremos

%union {
        int number = 0;
        char *string;
}

%token <string> ID STRING CTE_SHORT CTE_UINT CTE_DOUBLE
%type <string> factor constante

%start programa

%%

programa        : '{' sentencias '}'
                ;

sentencias      : sentencia
                | sentencias sentencia
                ;

sentencia       : declarativa ','
                | ejecutable ','
                ;

declarativa     : declaracion_variables { Logger::infoMsg("Declaracion de datos") }
                | clase_declaration
                | objeto_declaration
                | interface_declaration
                | implement_declaration
                | distributed_method_implementation
                | funcion_declaration
                ;

ejecutable      : asignacion
                | invocacion
                | seleccion
                | print
                | bucle_for
                | acceso_atributo
                ;

declaracion_variables   : tipo lista_variables
                        ;

lista_variables : lista_variables ';' ID
                | ID
                ;

clase_declaration       : CLASS ID '{' atributos metodos_clase herencia_composicion '}' { Logger::infoMsg("Declaracion de clase") }
                        ;

interface_declaration   : INTERFACE ID '{' interface_metodos '}' { Logger::infoMsg("Declaracion de interfaz") }
                        ;

interface_metodos       : interface_metodos interface_metodo_declaration
                        |
                        ;

interface_metodo_declaration    : VOID ID '(' parametro ')' ',' { Logger::infoMsg("Declaracion de metodo de interfaz") }
                                ;

implement_declaration   : CLASS ID IMPLEMENT ID '{' metodos_clase herencia_composicion '}' { Logger::infoMsg("Implementacion de interfaz") }
                        ;

atributos               : atributos atributo_declaration
                        |
                        ;

atributo_declaration    : declaracion_variables ',' { Logger::infoMsg("Declaracion de atributos de clase") }
                        ;

metodos_clase   : metodos_clase metodo_declaration
                |
                ;

metodo_declaration      : VOID ID '(' parametro ')' '{' sentencias_metodo '}' ',' { Logger::infoMsg("Declaracion de metodo") }
                        ;

funcion_declaration     : VOID ID '(' parametro ')' '{' sentencias_metodo '}' { Logger::infoMsg("Declaracion de funcion") }
                        |
                        ;

herencia_composicion    : herencia_composicion ID ','   { Logger::infoMsg("Herencia por composicion") }
                        |
                        ;

sentencias_metodo       : sentencias_metodo declaracion_variables ','
                        | sentencias_metodo retorno ','
                        | sentencias_metodo ejecutable ','
                        | sentencias_metodo funcion_declaration ','
                        |
                        ;

// Solo se permite un parametro en los metodos y funciones
parametro       : tipo ID
                |
                ;

distributed_method_implementation       : IMPL FOR ID ':' '{' metodos_clase '}'    { Logger::infoMsg("Declaracion distribuida") }
                                        ;
                        
retorno                 : RETURN        { Logger::infoMsg("Sentencia RETURN") }
                        ;

objeto_declaration      : ID lista_objetos
                        ;

lista_objetos           : lista_objetos ';' objeto
                        | objeto
                        ;

objeto          : ID
                ;

asignacion      : ID asignador expresion        { Logger::infoMsg("Asignacion simple") }
                | ID '.' ID asignador expresion  { Logger::infoMsg("Asignacion de atributo") }
                ;

asignador       : '='
                | PLUS_EQUAL    { Logger::infoMsg("Operador +=") }
                ;

invocacion      : ID '(' argumentos ')' { Logger::infoMsg("Invocacion de funcion") }
                | ID '.' ID '(' argumentos ')'  { Logger::infoMsg("Invocacion de metodo") }
                ;

argumentos      : expresion
                |
                ;

seleccion       : IF '(' condicion ')' bloque_sentencias ELSE bloque_sentencias END_IF  { Logger::infoMsg("Sentencia IF completa") }
                | IF '(' condicion ')' bloque_sentencias END_IF { Logger::infoMsg("Sentencia IF sin ELSE") }
                ;

condicion       : expresion comparador expresion        { Logger::infoMsg("Condicion de control") }
                ;

comparador      : '<'
                | '>'
                | LESS_EQUAL
                | GREATER_EQUAL
                | EQUAL
                | NOT_EQUAL
                ;
        
bloque_sentencias       : sentencia
                        | '{' sentencias '}'
                        ;

print   : PRINT STRING  { Logger::infoMsg("Sentencia PRINT") }
        ;

bucle_for       : FOR ID IN RANGE '(' constante ';' constante ';' constante ')' bloque_sentencias { Logger::infoMsg("Sentencia FOR") }
                ;

acceso_atributo : ID '.' ID     { Logger::infoMsg("Acceso a atributo") }
                ;

expresion       : expresion '+' termino { Logger::infoMsg("Suma") }
                | expresion '-' termino { Logger::infoMsg("Resta") }
                | termino
                | tipo '(' expresion ')' { Logger::logError("Conversion explicita no permitida") }
                | '(' expresion_parentesis ')' { Logger::infoMsg("Expresion entre parentesis") }
                ;

expresion_parentesis    : termino '+' termino
                        | termino '-' termino
                        | termino
                        | '(' expresion_parentesis ')' { Logger::logError("Anidamiento de expresiones con parentesis") }
                        ;

termino         : factor
                | termino '*' factor    { Logger::infoMsg("Multiplicacion") }
                | termino '/' factor { SyntacticActions::check_division_by_zero($3) }
                ;

factor          : ID
                | '-' constante { Logger::infoMsg("Constante negativa") }
                | constante
                ;

constante       : CTE_SHORT     { $$ = $1; Logger::infoMsg("Constante short") }
                | CTE_DOUBLE    { $$ = $1; Logger::infoMsg("Constante double") }
                | CTE_UINT      { $$ = $1; Logger::infoMsg("Constante uint") }
                ;

tipo    : SHORT
        | UINT
        | DOUBLE
        ;
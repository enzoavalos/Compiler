# Custom Compiler
This project is a custom compiler for a programming language with specific features and syntax, developed as part of the course "Dise√±o de Compiladores" at UNICEN. The compiler is written in C++ and uses Flex and Bison for lexical and syntactic analysis. It generates intermediate code using a three-address code representation and produces assembly code for Pentium 32 bits as output.

## Features
The programming language supported by the compiler has the following features:
- Short (8 bits) and unsigned integer (16 bits) data types
- Double (64 bits) floating point data type
- Constants
- String data type with single-line delimiters
- Arithmetic operations with overflow checking
- Assignment operator +=
- Comparison operators
- Selection (if) and iteration control structures (for-in-range)
- Functions, both local and global, and methods with parameters and return values
- Classes with attributes and methods
- Inheritance by composition with anonymous access to parent members
- Interfaces with method declarations and distributed implementation
- Comments with single-line delimiters

### Considerations
- The compiler **strictly enforces** type consistency, allowing only operations between operators of the **exact same data type**. Type conversions are **not supported**.
- The only valid syntax for declaring constants within this compiler is by using the format 0_s, where the number is followed by an underscore and the suffix corresponding to the desired data type (e.g., _s for shorts, _ui for unsigned integers).

## Supported Syntax
The following is an example of the syntax supported by the compiler:
```
SHORT int1 ; int2 ,
FOR i IN RANGE (2_s; 10_s; 1_s)
    int1 += i ,
,

INTERFACE my_interface {
    VOID interface_method (DOUBLE arg) ,
} ,

CLASS my_class IMPLEMENT my_interface {
    DOUBLE attribute ,

    VOID interface_method (DOUBLE arg){
        IF ( int1 !! 0_s )
            PRINT #not equal# ,
        END_IF ,
        RETURN ,
    } ,

    VOID method_prototype (UINT my_var) ,
},

IMPL FOR cc : {
    VOID method_prototype (UINT my_var){
        ...
    } ,
} ,

my_class instance ,
instance.attribute = 4.5d+20 ,
instance.method_prototype(2_ui) ,

```

### Examples of programs
The project directory contains some examples of programs written in the custom language, which you can use to test the compiler and see its features. The files can be found in the **Tests** folder. Each file contains comments explaining the purpose and functionality of the program.

## How to use the compiler
To use the compiler, run the following command from a console inside the project directory, at the same level as the main.cpp file:   
`.\executable <source_file>`

To re-compile the source code to obtain a new executable, run the following command from a console inside the project directory, at the same level as the main.cpp file:  
`g++ main.cpp -o <name_of_the_output_executable>`

## How to run the assembly code
To run the assembly code generated by the compiler, you will need an assembler and a linker compatible with Pentium 32 bits, such as [NASM](https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=D) and [GoLink](http://www.godevtool.com/GolinkHelp/GoLink.htm).
Once you have the assembler and the linker installed, you can run the following commands from a console inside the project directory, assuming the assembly code file is named output.asm:
`nasm -f win32 output.asm`
`GoLink /console output.obj`
This will produce an executable file named output.exe, which you can run to see the results of your program.
